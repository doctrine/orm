<?php

declare(strict_types = 1);

/*
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This software consists of voluntary contributions made by many individuals
 * and is licensed under the MIT license. For more information, see
 * <http://www.doctrine-project.org>.
 */

namespace Doctrine\ORM\Mapping\Factory;

use Doctrine\Common\Persistence\Mapping\ClassMetadataFactory;
use Doctrine\Common\Persistence\Mapping\ReflectionService;
use Doctrine\Common\Util\ClassUtils;
use Doctrine\ORM\Configuration\MetadataConfiguration;
use Doctrine\ORM\Mapping\ClassMetadata;

/**
 * AbstractClassMetadataFactory is the base of ClassMetadata object creation that contain all the metadata mapping
 * information of a class which describes how a class should be mapped to a relational database.
 *
 * @package Doctrine\ORM\Mapping\Factory
 * @since 3.0
 *
 * @author Guilherme Blanco <guilhermeblanco@hotmail.com>
 */
abstract class AbstractClassMetadataFactory implements ClassMetadataFactory
{
    /**
     * Never autogenerate a class metadata and rely that it was generated by some process before deployment.
     *
     * @var int
     */
    const AUTOGENERATE_NEVER = 0;

    /**
     * Always generates a new class metadata in every request. This is only sane during development.
     *
     * @var int
     */
    const AUTOGENERATE_ALWAYS = 1;

    /**
     * Autogenerate the class metadata when the file does not exist.
     * This strategy causes a file exists call whenever any metadata is used the first time in a request.
     *
     * @var int
     */
    const AUTOGENERATE_FILE_NOT_EXISTS = 2;

    /**
     * @var ClassMetadataDefinitionFactory
     */
    protected $definitionFactory;

    /**
     * @var ClassMetadataDriver
     */
    protected $metadataDriver;

    /**
     * @var NamingStrategy
     */
    protected $namingStrategy;

    /**
     * @var array<string, ClassMetadataDefinition>
     */
    private $definitions = [];

    /**
     * @var array<string, ClassMetadata>
     */
    private $loaded = [];

    /**
     * ClassMetadataFactory constructor.
     *
     * @param MetadataConfiguration $configuration
     */
    public function __construct(MetadataConfiguration $configuration)
    {
        $driver    = new ClassMetadataDriver($configuration->getMappingDriver(), $this->getReflectionService());
        $generator = new ClassMetadataGenerator($driver);

        $this->metadataDriver    = $driver;
        $this->namingStrategy    = $configuration->getNamingStrategy();
        $this->definitionFactory = new ClassMetadataDefinitionFactory(
            $configuration->getResolver(),
            $generator,
            $configuration->getAutoGenerate()
        );
    }

    /**
     * {@inheritdoc}
     */
    public function getAllMetadata()
    {
        $metadata = [];

        foreach ($this->metadataDriver->getAllClassMetadata() as $className) {
            $metadata[] = $this->getMetadataFor($className);
        }

        return $metadata;
    }

    /**
     * {@inheritdoc}
     */
    public function getMetadataFor($className)
    {
        $entityClassName = ClassUtils::getRealClass($className);

        if (isset($this->loaded[$entityClassName])) {
            return $this->loaded[$entityClassName];
        }

        $parentClassNameList   = $this->getParentClassNameList($className);
        $parentClassNameList[] = $className;
        $parent                = null;

        foreach ($parentClassNameList as $parentClassName) {
            if (isset($this->loaded[$parentClassName])) {
                $parent = $this->loaded[$parentClassName];

                continue;
            }

            $definition = $this->getOrCreateClassMetadataDefinition($entityClassName, $parent);

            $parent = $this->loaded[$entityClassName] = $this->createClassMetadata($definition);
        }

        return $this->loaded[$entityClassName];
    }

    /**
     * {@inheritdoc}
     */
    public function hasMetadataFor($className)
    {
        return isset($this->loaded[$className]);
    }

    /**
     * {@inheritdoc}
     */
    public function setMetadataFor($className, $class)
    {
        $this->loaded[$className] = $class;
    }

    /**
     * {@inheritdoc}
     */
    public function isTransient($className)
    {
        return $this->metadataDriver->hasClassMetadata($className);
    }

    /**
     * @param ClassMetadataDefinition $definition
     *
     * @return ClassMetadata
     */
    protected function createClassMetadata(ClassMetadataDefinition $definition) : ClassMetadata
    {
        /** @var ClassMetadata $classMetadata */
        $metadataFqcn  = $definition->metadataClassName;
        $classMetadata = new $metadataFqcn($definition->parent);

        $classMetadata->wakeupReflection($this->getReflectionService());

        return $classMetadata;
    }

    /**
     * Create a class metadata definition for the given class name.
     *
     * @param string             $className
     * @param ClassMetadata|null $parent
     *
     * @return ClassMetadataDefinition
     */
    private function getOrCreateClassMetadataDefinition(string $className, ?ClassMetadata $parent) : ClassMetadataDefinition
    {
        if (! isset($this->definitions[$className])) {
            $this->definitions[$className] = $this->definitionFactory->build($className, $parent);
        }

        return $this->definitions[$className];
    }

    /**
     * @param string $className
     *
     * @return array
     */
    private function getParentClassNameList(string $className) : array
    {
        $parentClassNameList = [];

        foreach (array_reverse($this->getReflectionService()->getParentClasses($className)) as $parentClassName) {
            if ($this->metadataDriver->hasClassMetadata($parentClassName)) {
                continue;
            }

            $parentClassNameList[] = $parentClassName;
        }

        return $parentClassNameList;
    }

    /**
     * @return ReflectionService
     */
    abstract protected function getReflectionService();
}
